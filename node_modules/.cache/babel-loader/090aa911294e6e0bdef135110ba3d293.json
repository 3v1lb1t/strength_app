{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar motionUtils = require('motion-utils');\nconst supportsScrollTimeline = /* @__PURE__ */motionUtils.memo(() => window.ScrollTimeline !== undefined);\nclass GroupAnimation {\n  constructor(animations) {\n    // Bound to accomodate common `return animation.stop` pattern\n    this.stop = () => this.runAll(\"stop\");\n    this.animations = animations.filter(Boolean);\n  }\n  get finished() {\n    return Promise.all(this.animations.map(animation => animation.finished));\n  }\n  /**\n   * TODO: Filter out cancelled or stopped animations before returning\n   */\n  getAll(propName) {\n    return this.animations[0][propName];\n  }\n  setAll(propName, newValue) {\n    for (let i = 0; i < this.animations.length; i++) {\n      this.animations[i][propName] = newValue;\n    }\n  }\n  attachTimeline(timeline, fallback) {\n    const subscriptions = this.animations.map(animation => {\n      if (supportsScrollTimeline() && animation.attachTimeline) {\n        return animation.attachTimeline(timeline);\n      } else if (typeof fallback === \"function\") {\n        return fallback(animation);\n      }\n    });\n    return () => {\n      subscriptions.forEach((cancel, i) => {\n        cancel && cancel();\n        this.animations[i].stop();\n      });\n    };\n  }\n  get time() {\n    return this.getAll(\"time\");\n  }\n  set time(time) {\n    this.setAll(\"time\", time);\n  }\n  get speed() {\n    return this.getAll(\"speed\");\n  }\n  set speed(speed) {\n    this.setAll(\"speed\", speed);\n  }\n  get startTime() {\n    return this.getAll(\"startTime\");\n  }\n  get duration() {\n    let max = 0;\n    for (let i = 0; i < this.animations.length; i++) {\n      max = Math.max(max, this.animations[i].duration);\n    }\n    return max;\n  }\n  runAll(methodName) {\n    this.animations.forEach(controls => controls[methodName]());\n  }\n  flatten() {\n    this.runAll(\"flatten\");\n  }\n  play() {\n    this.runAll(\"play\");\n  }\n  pause() {\n    this.runAll(\"pause\");\n  }\n  cancel() {\n    this.runAll(\"cancel\");\n  }\n  complete() {\n    this.runAll(\"complete\");\n  }\n}\nclass GroupAnimationWithThen extends GroupAnimation {\n  then(onResolve, _onReject) {\n    return this.finished.finally(onResolve).then(() => {});\n  }\n}\nconst isCSSVar = name => name.startsWith(\"--\");\nconst style$1 = {\n  set: (element, name, value) => {\n    isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;\n  },\n  get: (element, name) => {\n    return isCSSVar(name) ? element.style.getPropertyValue(name) : element.style[name];\n  }\n};\nconst isNotNull = value => value !== null;\nfunction getFinalKeyframe(keyframes, {\n  repeat,\n  repeatType = \"loop\"\n}, finalKeyframe) {\n  const resolvedKeyframes = keyframes.filter(isNotNull);\n  const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;\n  return !index || finalKeyframe === undefined ? resolvedKeyframes[index] : finalKeyframe;\n}\nconst supportsPartialKeyframes = /*@__PURE__*/motionUtils.memo(() => {\n  try {\n    document.createElement(\"div\").animate({\n      opacity: [1]\n    });\n  } catch (e) {\n    return false;\n  }\n  return true;\n});\nconst pxValues = new Set([\n// Border props\n\"borderWidth\", \"borderTopWidth\", \"borderRightWidth\", \"borderBottomWidth\", \"borderLeftWidth\", \"borderRadius\", \"radius\", \"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomRightRadius\", \"borderBottomLeftRadius\",\n// Positioning props\n\"width\", \"maxWidth\", \"height\", \"maxHeight\", \"top\", \"right\", \"bottom\", \"left\",\n// Spacing props\n\"padding\", \"paddingTop\", \"paddingRight\", \"paddingBottom\", \"paddingLeft\", \"margin\", \"marginTop\", \"marginRight\", \"marginBottom\", \"marginLeft\",\n// Misc\n\"backgroundPositionX\", \"backgroundPositionY\"]);\nfunction hydrateKeyframes(element, name, keyframes, pseudoElement) {\n  if (!Array.isArray(keyframes)) {\n    keyframes = [keyframes];\n  }\n  for (let i = 0; i < keyframes.length; i++) {\n    if (keyframes[i] === null) {\n      keyframes[i] = i === 0 && !pseudoElement ? style$1.get(element, name) : keyframes[i - 1];\n    }\n    if (typeof keyframes[i] === \"number\" && pxValues.has(name)) {\n      keyframes[i] = keyframes[i] + \"px\";\n    }\n  }\n  if (!pseudoElement && !supportsPartialKeyframes() && keyframes.length < 2) {\n    keyframes.unshift(style$1.get(element, name));\n  }\n  return keyframes;\n}\nconst activeAnimations = {\n  layout: 0,\n  mainThread: 0,\n  waapi: 0\n};\nconst statsBuffer = {\n  value: null,\n  addProjectionMetrics: null\n};\nconst isBezierDefinition = easing => Array.isArray(easing) && typeof easing[0] === \"number\";\n\n/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {};\nfunction memoSupports(callback, supportsFlag) {\n  const memoized = motionUtils.memo(callback);\n  return () => supportsFlags[supportsFlag] ?? memoized();\n}\nconst supportsLinearEasing = /*@__PURE__*/memoSupports(() => {\n  try {\n    document.createElement(\"div\").animate({\n      opacity: 0\n    }, {\n      easing: \"linear(0, 1)\"\n    });\n  } catch (e) {\n    return false;\n  }\n  return true;\n}, \"linearEasing\");\nconst generateLinearEasing = (easing, duration,\n// as milliseconds\nresolution = 10 // as milliseconds\n) => {\n  let points = \"\";\n  const numPoints = Math.max(Math.round(duration / resolution), 2);\n  for (let i = 0; i < numPoints; i++) {\n    points += easing(i / (numPoints - 1)) + \", \";\n  }\n  return `linear(${points.substring(0, points.length - 2)})`;\n};\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n  linear: \"linear\",\n  ease: \"ease\",\n  easeIn: \"ease-in\",\n  easeOut: \"ease-out\",\n  easeInOut: \"ease-in-out\",\n  circIn: /*@__PURE__*/cubicBezierAsString([0, 0.65, 0.55, 1]),\n  circOut: /*@__PURE__*/cubicBezierAsString([0.55, 0, 1, 0.45]),\n  backIn: /*@__PURE__*/cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n  backOut: /*@__PURE__*/cubicBezierAsString([0.33, 1.53, 0.69, 0.99])\n};\nfunction mapEasingToNativeEasing(easing, duration) {\n  if (!easing) {\n    return undefined;\n  } else if (typeof easing === \"function\" && supportsLinearEasing()) {\n    return generateLinearEasing(easing, duration);\n  } else if (isBezierDefinition(easing)) {\n    return cubicBezierAsString(easing);\n  } else if (Array.isArray(easing)) {\n    return easing.map(segmentEasing => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);\n  } else {\n    return supportedWaapiEasing[easing];\n  }\n}\nfunction startWaapiAnimation(element, valueName, keyframes, {\n  delay = 0,\n  duration = 300,\n  repeat = 0,\n  repeatType = \"loop\",\n  ease = \"easeInOut\",\n  times\n} = {}, pseudoElement = undefined) {\n  const keyframeOptions = {\n    [valueName]: keyframes\n  };\n  if (times) keyframeOptions.offset = times;\n  const easing = mapEasingToNativeEasing(ease, duration);\n  /**\n   * If this is an easing array, apply to keyframes, not animation as a whole\n   */\n  if (Array.isArray(easing)) keyframeOptions.easing = easing;\n  if (statsBuffer.value) {\n    activeAnimations.waapi++;\n  }\n  const animation = element.animate(keyframeOptions, {\n    delay,\n    duration,\n    easing: !Array.isArray(easing) ? easing : \"linear\",\n    fill: \"both\",\n    iterations: repeat + 1,\n    direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    pseudoElement\n  });\n  if (statsBuffer.value) {\n    animation.finished.finally(() => {\n      activeAnimations.waapi--;\n    });\n  }\n  return animation;\n}\nfunction isGenerator(type) {\n  return typeof type === \"function\" && \"applyToOptions\" in type;\n}\nfunction applyGeneratorOptions({\n  type,\n  ...options\n}) {\n  if (isGenerator(type)) {\n    return type.applyToOptions(options);\n  } else {\n    options.duration ?? (options.duration = 300);\n    options.ease ?? (options.ease = \"easeOut\");\n  }\n  return options;\n}\nconst animationMaps = new WeakMap();\nconst animationMapKey = (name, pseudoElement) => `${name}:${pseudoElement}`;\nfunction getAnimationMap(element) {\n  const map = animationMaps.get(element) || new Map();\n  animationMaps.set(element, map);\n  return map;\n}\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nclass NativeAnimation {\n  constructor(options) {\n    /**\n     * If we already have an animation, we don't need to instantiate one\n     * and can just use this as a controls interface.\n     */\n    if (\"animation\" in options) {\n      this.animation = options.animation;\n      return;\n    }\n    const {\n      element,\n      name,\n      keyframes: unresolvedKeyframes,\n      pseudoElement,\n      allowFlatten = false\n    } = options;\n    let {\n      transition\n    } = options;\n    this.isPseudoElement = Boolean(pseudoElement);\n    this.allowFlatten = allowFlatten;\n    /**\n     * Stop any existing animations on the element before reading existing keyframes.\n     *\n     * TODO: Check for VisualElement before using animation state. This is a fallback\n     * for mini animate(). Do this when implementing NativeAnimationExtended.\n     */\n    const animationMap = getAnimationMap(element);\n    const key = animationMapKey(name, pseudoElement || \"\");\n    const currentAnimation = animationMap.get(key);\n    currentAnimation && currentAnimation.stop();\n    /**\n     * TODO: If these keyframes aren't correctly hydrated then we want to throw\n     * run an instant animation.\n     */\n    const keyframes = hydrateKeyframes(element, name, unresolvedKeyframes, pseudoElement);\n    motionUtils.invariant(typeof transition.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"motion\"?`);\n    transition = applyGeneratorOptions(transition);\n    this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n    if (transition.autoplay === false) {\n      this.animation.pause();\n    }\n    this.removeAnimation = () => animationMap.delete(key);\n    this.animation.onfinish = () => {\n      if (!pseudoElement) {\n        style$1.set(element, name, getFinalKeyframe(keyframes, transition));\n        this.cancel();\n      }\n    };\n    /**\n     * TODO: Check for VisualElement before using animation state.\n     */\n    animationMap.set(key, this);\n  }\n  play() {\n    this.animation.play();\n  }\n  pause() {\n    this.animation.pause();\n  }\n  complete() {\n    this.animation.finish();\n  }\n  cancel() {\n    try {\n      this.animation.cancel();\n    } catch (e) {}\n    this.removeAnimation();\n  }\n  stop() {\n    const {\n      state\n    } = this;\n    if (state === \"idle\" || state === \"finished\") {\n      return;\n    }\n    this.commitStyles();\n    this.cancel();\n  }\n  /**\n   * WAAPI doesn't natively have any interruption capabilities.\n   *\n   * In this method, we commit styles back to the DOM before cancelling\n   * the animation.\n   *\n   * This is designed to be overridden by NativeAnimationExtended, which\n   * will create a renderless JS animation and sample it twice to calculate\n   * its current value, \"previous\" value, and therefore allow\n   * Motion to also correctly calculate velocity for any subsequent animation\n   * while deferring the commit until the next animation frame.\n   */\n  commitStyles() {\n    if (!this.isPseudoElement) {\n      this.animation.commitStyles?.();\n    }\n  }\n  get duration() {\n    const duration = this.animation.effect?.getComputedTiming().duration || 0;\n    return motionUtils.millisecondsToSeconds(Number(duration));\n  }\n  get time() {\n    return motionUtils.millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n  }\n  set time(newTime) {\n    this.animation.currentTime = motionUtils.secondsToMilliseconds(newTime);\n  }\n  /**\n   * The playback speed of the animation.\n   * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n   */\n  get speed() {\n    return this.animation.playbackRate;\n  }\n  set speed(newSpeed) {\n    this.animation.playbackRate = newSpeed;\n  }\n  get state() {\n    return this.animation.playState;\n  }\n  get startTime() {\n    return Number(this.animation.startTime);\n  }\n  get finished() {\n    return this.animation.finished;\n  }\n  flatten() {\n    if (this.allowFlatten) {\n      this.animation.effect?.updateTiming({\n        easing: \"linear\"\n      });\n    }\n  }\n  /**\n   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n   */\n  attachTimeline(timeline) {\n    this.animation.timeline = timeline;\n    this.animation.onfinish = null;\n    return motionUtils.noop;\n  }\n  /**\n   * Allows the animation to be awaited.\n   *\n   * @deprecated Use `finished` instead.\n   */\n  then(onResolve, onReject) {\n    return this.finished.then(onResolve).catch(onReject);\n  }\n}\nfunction getValueTransition(transition, key) {\n  return transition?.[key] ?? transition?.[\"default\"] ?? transition;\n}\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n  let duration = 0;\n  const timeStep = 50;\n  let state = generator.next(duration);\n  while (!state.done && duration < maxGeneratorDuration) {\n    duration += timeStep;\n    state = generator.next(duration);\n  }\n  return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100, createGenerator) {\n  const generator = createGenerator({\n    ...options,\n    keyframes: [0, scale]\n  });\n  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n  return {\n    type: \"keyframes\",\n    ease: progress => {\n      return generator.next(duration * progress).value / scale;\n    },\n    duration: motionUtils.millisecondsToSeconds(duration)\n  };\n}\nfunction isWaapiSupportedEasing(easing) {\n  return Boolean(typeof easing === \"function\" && supportsLinearEasing() || !easing || typeof easing === \"string\" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));\n}\nfunction attachTimeline(animation, timeline) {\n  animation.timeline = timeline;\n  animation.onfinish = null;\n}\nconst stepsOrder = [\"read\",\n// Read\n\"resolveKeyframes\",\n// Write/Read/Write/Read\n\"update\",\n// Compute\n\"preRender\",\n// Compute\n\"render\",\n// Write\n\"postRender\" // Compute\n];\nfunction createRenderStep(runNextFrame, stepName) {\n  /**\n   * We create and reuse two queues, one to queue jobs for the current frame\n   * and one for the next. We reuse to avoid triggering GC after x frames.\n   */\n  let thisFrame = new Set();\n  let nextFrame = new Set();\n  /**\n   * Track whether we're currently processing jobs in this step. This way\n   * we can decide whether to schedule new jobs for this frame or next.\n   */\n  let isProcessing = false;\n  let flushNextFrame = false;\n  /**\n   * A set of processes which were marked keepAlive when scheduled.\n   */\n  const toKeepAlive = new WeakSet();\n  let latestFrameData = {\n    delta: 0.0,\n    timestamp: 0.0,\n    isProcessing: false\n  };\n  let numCalls = 0;\n  function triggerCallback(callback) {\n    if (toKeepAlive.has(callback)) {\n      step.schedule(callback);\n      runNextFrame();\n    }\n    numCalls++;\n    callback(latestFrameData);\n  }\n  const step = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing;\n      const queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n      if (!queue.has(callback)) queue.add(callback);\n      return callback;\n    },\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: callback => {\n      nextFrame.delete(callback);\n      toKeepAlive.delete(callback);\n    },\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: frameData => {\n      latestFrameData = frameData;\n      /**\n       * If we're already processing we've probably been triggered by a flushSync\n       * inside an existing process. Instead of executing, mark flushNextFrame\n       * as true and ensure we flush the following frame at the end of this one.\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing = true;\n      [thisFrame, nextFrame] = [nextFrame, thisFrame];\n      // Execute this frame\n      thisFrame.forEach(triggerCallback);\n      /**\n       * If we're recording stats then\n       */\n      if (stepName && statsBuffer.value) {\n        statsBuffer.value.frameloop[stepName].push(numCalls);\n      }\n      numCalls = 0;\n      // Clear the frame so no callbacks remain. This is to avoid\n      // memory leaks should this render step not run for a while.\n      thisFrame.clear();\n      isProcessing = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n  let runNextFrame = false;\n  let useDefaultElapsed = true;\n  const state = {\n    delta: 0.0,\n    timestamp: 0.0,\n    isProcessing: false\n  };\n  const flagRunNextFrame = () => runNextFrame = true;\n  const steps = stepsOrder.reduce((acc, key) => {\n    acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);\n    return acc;\n  }, {});\n  const {\n    read,\n    resolveKeyframes,\n    update,\n    preRender,\n    render,\n    postRender\n  } = steps;\n  const processBatch = () => {\n    const timestamp = motionUtils.MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();\n    runNextFrame = false;\n    if (!motionUtils.MotionGlobalConfig.useManualTiming) {\n      state.delta = useDefaultElapsed ? 1000 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n    }\n    state.timestamp = timestamp;\n    state.isProcessing = true;\n    // Unrolled render loop for better per-frame performance\n    read.process(state);\n    resolveKeyframes.process(state);\n    update.process(state);\n    preRender.process(state);\n    render.process(state);\n    postRender.process(state);\n    state.isProcessing = false;\n    if (runNextFrame && allowKeepAlive) {\n      useDefaultElapsed = false;\n      scheduleNextBatch(processBatch);\n    }\n  };\n  const wake = () => {\n    runNextFrame = true;\n    useDefaultElapsed = true;\n    if (!state.isProcessing) {\n      scheduleNextBatch(processBatch);\n    }\n  };\n  const schedule = stepsOrder.reduce((acc, key) => {\n    const step = steps[key];\n    acc[key] = (process, keepAlive = false, immediate = false) => {\n      if (!runNextFrame) wake();\n      return step.schedule(process, keepAlive, immediate);\n    };\n    return acc;\n  }, {});\n  const cancel = process => {\n    for (let i = 0; i < stepsOrder.length; i++) {\n      steps[stepsOrder[i]].cancel(process);\n    }\n  };\n  return {\n    schedule,\n    cancel,\n    state,\n    steps\n  };\n}\nconst {\n  schedule: frame,\n  cancel: cancelFrame,\n  state: frameData,\n  steps: frameSteps\n} = /* @__PURE__ */createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : motionUtils.noop, true);\nconst {\n  schedule: microtask,\n  cancel: cancelMicrotask\n} = /* @__PURE__ */createRenderBatcher(queueMicrotask, false);\nlet now;\nfunction clearTime() {\n  now = undefined;\n}\n/**\n * An eventloop-synchronous alternative to performance.now().\n *\n * Ensures that time measurements remain consistent within a synchronous context.\n * Usually calling performance.now() twice within the same synchronous context\n * will return different values which isn't useful for animations when we're usually\n * trying to sync animations to the same frame.\n */\nconst time = {\n  now: () => {\n    if (now === undefined) {\n      time.set(frameData.isProcessing || motionUtils.MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());\n    }\n    return now;\n  },\n  set: newTime => {\n    now = newTime;\n    queueMicrotask(clearTime);\n  }\n};\nconst isDragging = {\n  x: false,\n  y: false\n};\nfunction isDragActive() {\n  return isDragging.x || isDragging.y;\n}\nfunction setDragLock(axis) {\n  if (axis === \"x\" || axis === \"y\") {\n    if (isDragging[axis]) {\n      return null;\n    } else {\n      isDragging[axis] = true;\n      return () => {\n        isDragging[axis] = false;\n      };\n    }\n  } else {\n    if (isDragging.x || isDragging.y) {\n      return null;\n    } else {\n      isDragging.x = isDragging.y = true;\n      return () => {\n        isDragging.x = isDragging.y = false;\n      };\n    }\n  }\n}\nfunction resolveElements(elementOrSelector, scope, selectorCache) {\n  if (elementOrSelector instanceof EventTarget) {\n    return [elementOrSelector];\n  } else if (typeof elementOrSelector === \"string\") {\n    let root = document;\n    if (scope) {\n      root = scope.current;\n    }\n    const elements = selectorCache?.[elementOrSelector] ?? root.querySelectorAll(elementOrSelector);\n    return elements ? Array.from(elements) : [];\n  }\n  return Array.from(elementOrSelector);\n}\nfunction setupGesture(elementOrSelector, options) {\n  const elements = resolveElements(elementOrSelector);\n  const gestureAbortController = new AbortController();\n  const eventOptions = {\n    passive: true,\n    ...options,\n    signal: gestureAbortController.signal\n  };\n  const cancel = () => gestureAbortController.abort();\n  return [elements, eventOptions, cancel];\n}\nfunction isValidHover(event) {\n  return !(event.pointerType === \"touch\" || isDragActive());\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n  const onPointerEnter = enterEvent => {\n    if (!isValidHover(enterEvent)) return;\n    const {\n      target\n    } = enterEvent;\n    const onHoverEnd = onHoverStart(target, enterEvent);\n    if (typeof onHoverEnd !== \"function\" || !target) return;\n    const onPointerLeave = leaveEvent => {\n      if (!isValidHover(leaveEvent)) return;\n      onHoverEnd(leaveEvent);\n      target.removeEventListener(\"pointerleave\", onPointerLeave);\n    };\n    target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n  };\n  elements.forEach(element => {\n    element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n  });\n  return cancel;\n}\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nconst isNodeOrChild = (parent, child) => {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\nconst isPrimaryPointer = event => {\n  if (event.pointerType === \"mouse\") {\n    return typeof event.button !== \"number\" || event.button <= 0;\n  } else {\n    /**\n     * isPrimary is true for all mice buttons, whereas every touch point\n     * is regarded as its own input. So subsequent concurrent touch points\n     * will be false.\n     *\n     * Specifically match against false here as incomplete versions of\n     * PointerEvents in very old browser might have it set as undefined.\n     */\n    return event.isPrimary !== false;\n  }\n};\nconst focusableElements = new Set([\"BUTTON\", \"INPUT\", \"SELECT\", \"TEXTAREA\", \"A\"]);\nfunction isElementKeyboardAccessible(element) {\n  return focusableElements.has(element.tagName) || element.tabIndex !== -1;\n}\nconst isPressing = new WeakSet();\n\n/**\n * Filter out events that are not \"Enter\" keys.\n */\nfunction filterEvents(callback) {\n  return event => {\n    if (event.key !== \"Enter\") return;\n    callback(event);\n  };\n}\nfunction firePointerEvent(target, type) {\n  target.dispatchEvent(new PointerEvent(\"pointer\" + type, {\n    isPrimary: true,\n    bubbles: true\n  }));\n}\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\n  const element = focusEvent.currentTarget;\n  if (!element) return;\n  const handleKeydown = filterEvents(() => {\n    if (isPressing.has(element)) return;\n    firePointerEvent(element, \"down\");\n    const handleKeyup = filterEvents(() => {\n      firePointerEvent(element, \"up\");\n    });\n    const handleBlur = () => firePointerEvent(element, \"cancel\");\n    element.addEventListener(\"keyup\", handleKeyup, eventOptions);\n    element.addEventListener(\"blur\", handleBlur, eventOptions);\n  });\n  element.addEventListener(\"keydown\", handleKeydown, eventOptions);\n  /**\n   * Add an event listener that fires on blur to remove the keydown events.\n   */\n  element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\n};\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n  return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(targetOrSelector, onPressStart, options = {}) {\n  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\n  const startPress = startEvent => {\n    const target = startEvent.currentTarget;\n    if (!isValidPressEvent(startEvent) || isPressing.has(target)) return;\n    isPressing.add(target);\n    const onPressEnd = onPressStart(target, startEvent);\n    const onPointerEnd = (endEvent, success) => {\n      window.removeEventListener(\"pointerup\", onPointerUp);\n      window.removeEventListener(\"pointercancel\", onPointerCancel);\n      if (!isValidPressEvent(endEvent) || !isPressing.has(target)) {\n        return;\n      }\n      isPressing.delete(target);\n      if (typeof onPressEnd === \"function\") {\n        onPressEnd(endEvent, {\n          success\n        });\n      }\n    };\n    const onPointerUp = upEvent => {\n      onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));\n    };\n    const onPointerCancel = cancelEvent => {\n      onPointerEnd(cancelEvent, false);\n    };\n    window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n    window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n  };\n  targets.forEach(target => {\n    const pointerDownTarget = options.useGlobalTarget ? window : target;\n    pointerDownTarget.addEventListener(\"pointerdown\", startPress, eventOptions);\n    if (target instanceof HTMLElement) {\n      target.addEventListener(\"focus\", event => enableKeyboardPress(event, eventOptions));\n      if (!isElementKeyboardAccessible(target) && !target.hasAttribute(\"tabindex\")) {\n        target.tabIndex = 0;\n      }\n    }\n  });\n  return cancelEvents;\n}\nfunction record() {\n  const {\n    value\n  } = statsBuffer;\n  if (value === null) {\n    cancelFrame(record);\n    return;\n  }\n  value.frameloop.rate.push(frameData.delta);\n  value.animations.mainThread.push(activeAnimations.mainThread);\n  value.animations.waapi.push(activeAnimations.waapi);\n  value.animations.layout.push(activeAnimations.layout);\n}\nfunction mean(values) {\n  return values.reduce((acc, value) => acc + value, 0) / values.length;\n}\nfunction summarise(values, calcAverage = mean) {\n  if (values.length === 0) {\n    return {\n      min: 0,\n      max: 0,\n      avg: 0\n    };\n  }\n  return {\n    min: Math.min(...values),\n    max: Math.max(...values),\n    avg: calcAverage(values)\n  };\n}\nconst msToFps = ms => Math.round(1000 / ms);\nfunction clearStatsBuffer() {\n  statsBuffer.value = null;\n  statsBuffer.addProjectionMetrics = null;\n}\nfunction reportStats() {\n  const {\n    value\n  } = statsBuffer;\n  if (!value) {\n    throw new Error(\"Stats are not being measured\");\n  }\n  clearStatsBuffer();\n  cancelFrame(record);\n  const summary = {\n    frameloop: {\n      rate: summarise(value.frameloop.rate),\n      read: summarise(value.frameloop.read),\n      resolveKeyframes: summarise(value.frameloop.resolveKeyframes),\n      update: summarise(value.frameloop.update),\n      preRender: summarise(value.frameloop.preRender),\n      render: summarise(value.frameloop.render),\n      postRender: summarise(value.frameloop.postRender)\n    },\n    animations: {\n      mainThread: summarise(value.animations.mainThread),\n      waapi: summarise(value.animations.waapi),\n      layout: summarise(value.animations.layout)\n    },\n    layoutProjection: {\n      nodes: summarise(value.layoutProjection.nodes),\n      calculatedTargetDeltas: summarise(value.layoutProjection.calculatedTargetDeltas),\n      calculatedProjections: summarise(value.layoutProjection.calculatedProjections)\n    }\n  };\n  /**\n   * Convert the rate to FPS\n   */\n  const {\n    rate\n  } = summary.frameloop;\n  rate.min = msToFps(rate.min);\n  rate.max = msToFps(rate.max);\n  rate.avg = msToFps(rate.avg);\n  [rate.min, rate.max] = [rate.max, rate.min];\n  return summary;\n}\nfunction recordStats() {\n  if (statsBuffer.value) {\n    clearStatsBuffer();\n    throw new Error(\"Stats are already being measured\");\n  }\n  const newStatsBuffer = statsBuffer;\n  newStatsBuffer.value = {\n    frameloop: {\n      rate: [],\n      read: [],\n      resolveKeyframes: [],\n      update: [],\n      preRender: [],\n      render: [],\n      postRender: []\n    },\n    animations: {\n      mainThread: [],\n      waapi: [],\n      layout: []\n    },\n    layoutProjection: {\n      nodes: [],\n      calculatedTargetDeltas: [],\n      calculatedProjections: []\n    }\n  };\n  newStatsBuffer.addProjectionMetrics = metrics => {\n    const {\n      layoutProjection\n    } = newStatsBuffer.value;\n    layoutProjection.nodes.push(metrics.nodes);\n    layoutProjection.calculatedTargetDeltas.push(metrics.calculatedTargetDeltas);\n    layoutProjection.calculatedProjections.push(metrics.calculatedProjections);\n  };\n  frame.postRender(record, true);\n  return reportStats;\n}\n\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */\nconst MAX_VELOCITY_DELTA = 30;\nconst isFloat = value => {\n  return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n  current: undefined\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   */\n  constructor(init, options = {}) {\n    /**\n     * This will be replaced by the build step with the latest version number.\n     * When MotionValues are provided to motion components, warn if versions are mixed.\n     */\n    this.version = \"12.7.4\";\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n    this.canTrackVelocity = null;\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    this.events = {};\n    this.updateAndNotify = (v, render = true) => {\n      const currentTime = time.now();\n      /**\n       * If we're updating the value during another frame or eventloop\n       * than the previous frame, then the we set the previous frame value\n       * to current.\n       */\n      if (this.updatedAt !== currentTime) {\n        this.setPrevFrameValue();\n      }\n      this.prev = this.current;\n      this.setCurrent(v);\n      // Update update subscribers\n      if (this.current !== this.prev && this.events.change) {\n        this.events.change.notify(this.current);\n      }\n      // Update render subscribers\n      if (render && this.events.renderRequest) {\n        this.events.renderRequest.notify(this.current);\n      }\n    };\n    this.hasAnimated = false;\n    this.setCurrent(init);\n    this.owner = options.owner;\n  }\n  setCurrent(current) {\n    this.current = current;\n    this.updatedAt = time.now();\n    if (this.canTrackVelocity === null && current !== undefined) {\n      this.canTrackVelocity = isFloat(this.current);\n    }\n  }\n  setPrevFrameValue(prevFrameValue = this.current) {\n    this.prevFrameValue = prevFrameValue;\n    this.prevUpdatedAt = this.updatedAt;\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.on(\"change\", updateOpacity)\n   *     const unsubscribeY = y.on(\"change\", updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @deprecated\n   */\n  onChange(subscription) {\n    if (process.env.NODE_ENV !== \"production\") {\n      motionUtils.warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n    }\n    return this.on(\"change\", subscription);\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new motionUtils.SubscriptionManager();\n    }\n    const unsubscribe = this.events[eventName].add(callback);\n    if (eventName === \"change\") {\n      return () => {\n        unsubscribe();\n        /**\n         * If we have no more change listeners by the start\n         * of the next frame, stop active animations.\n         */\n        frame.read(() => {\n          if (!this.events.change.getSize()) {\n            this.stop();\n          }\n        });\n      };\n    }\n    return unsubscribe;\n  }\n  clearListeners() {\n    for (const eventManagers in this.events) {\n      this.events[eventManagers].clear();\n    }\n  }\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   */\n  attach(passiveEffect, stopPassiveEffect) {\n    this.passiveEffect = passiveEffect;\n    this.stopPassiveEffect = stopPassiveEffect;\n  }\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n  set(v, render = true) {\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  }\n  setWithVelocity(prev, current, delta) {\n    this.set(current);\n    this.prev = undefined;\n    this.prevFrameValue = prev;\n    this.prevUpdatedAt = this.updatedAt - delta;\n  }\n  /**\n   * Set the state of the `MotionValue`, stopping any active animations,\n   * effects, and resets velocity to `0`.\n   */\n  jump(v, endAnimation = true) {\n    this.updateAndNotify(v);\n    this.prev = v;\n    this.prevUpdatedAt = this.prevFrameValue = undefined;\n    endAnimation && this.stop();\n    if (this.stopPassiveEffect) this.stopPassiveEffect();\n  }\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n  get() {\n    if (collectMotionValues.current) {\n      collectMotionValues.current.push(this);\n    }\n    return this.current;\n  }\n  /**\n   * @public\n   */\n  getPrevious() {\n    return this.prev;\n  }\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n  getVelocity() {\n    const currentTime = time.now();\n    if (!this.canTrackVelocity || this.prevFrameValue === undefined || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\n      return 0;\n    }\n    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\n    // Casts because of parseFloat's poor typing\n    return motionUtils.velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);\n  }\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   */\n  start(startAnimation) {\n    this.stop();\n    return new Promise(resolve => {\n      this.hasAnimated = true;\n      this.animation = startAnimation(resolve);\n      if (this.events.animationStart) {\n        this.events.animationStart.notify();\n      }\n    }).then(() => {\n      if (this.events.animationComplete) {\n        this.events.animationComplete.notify();\n      }\n      this.clearAnimation();\n    });\n  }\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n  stop() {\n    if (this.animation) {\n      this.animation.stop();\n      if (this.events.animationCancel) {\n        this.events.animationCancel.notify();\n      }\n    }\n    this.clearAnimation();\n  }\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n  isAnimating() {\n    return !!this.animation;\n  }\n  clearAnimation() {\n    delete this.animation;\n  }\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n  destroy() {\n    this.clearListeners();\n    this.stop();\n    if (this.stopPassiveEffect) {\n      this.stopPassiveEffect();\n    }\n  }\n}\nfunction motionValue(init, options) {\n  return new MotionValue(init, options);\n}\nfunction chooseLayerType(valueName) {\n  if (valueName === \"layout\") return \"group\";\n  if (valueName === \"enter\" || valueName === \"new\") return \"new\";\n  if (valueName === \"exit\" || valueName === \"old\") return \"old\";\n  return \"group\";\n}\nlet pendingRules = {};\nlet style = null;\nconst css = {\n  set: (selector, values) => {\n    pendingRules[selector] = values;\n  },\n  commit: () => {\n    if (!style) {\n      style = document.createElement(\"style\");\n      style.id = \"motion-view\";\n    }\n    let cssText = \"\";\n    for (const selector in pendingRules) {\n      const rule = pendingRules[selector];\n      cssText += `${selector} {\\n`;\n      for (const [property, value] of Object.entries(rule)) {\n        cssText += `  ${property}: ${value};\\n`;\n      }\n      cssText += \"}\\n\";\n    }\n    style.textContent = cssText;\n    document.head.appendChild(style);\n    pendingRules = {};\n  },\n  remove: () => {\n    if (style && style.parentElement) {\n      style.parentElement.removeChild(style);\n    }\n  }\n};\nfunction getLayerName(pseudoElement) {\n  const match = pseudoElement.match(/::view-transition-(old|new|group|image-pair)\\((.*?)\\)/);\n  if (!match) return null;\n  return {\n    layer: match[2],\n    type: match[1]\n  };\n}\nfunction filterViewAnimations(animation) {\n  const {\n    effect\n  } = animation;\n  if (!effect) return false;\n  return effect.target === document.documentElement && effect.pseudoElement?.startsWith(\"::view-transition\");\n}\nfunction getViewAnimations() {\n  return document.getAnimations().filter(filterViewAnimations);\n}\nfunction hasTarget(target, targets) {\n  return targets.has(target) && Object.keys(targets.get(target)).length > 0;\n}\nconst definitionNames = [\"layout\", \"enter\", \"exit\", \"new\", \"old\"];\nfunction startViewAnimation(builder) {\n  const {\n    update,\n    targets,\n    options: defaultOptions\n  } = builder;\n  if (!document.startViewTransition) {\n    return new Promise(async resolve => {\n      await update();\n      resolve(new GroupAnimation([]));\n    });\n  }\n  // TODO: Go over existing targets and ensure they all have ids\n  /**\n   * If we don't have any animations defined for the root target,\n   * remove it from being captured.\n   */\n  if (!hasTarget(\"root\", targets)) {\n    css.set(\":root\", {\n      \"view-transition-name\": \"none\"\n    });\n  }\n  /**\n   * Set the timing curve to linear for all view transition layers.\n   * This gets baked into the keyframes, which can't be changed\n   * without breaking the generated animation.\n   *\n   * This allows us to set easing via updateTiming - which can be changed.\n   */\n  css.set(\"::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)\", {\n    \"animation-timing-function\": \"linear !important\"\n  });\n  css.commit(); // Write\n  const transition = document.startViewTransition(async () => {\n    await update();\n    // TODO: Go over new targets and ensure they all have ids\n  });\n  transition.finished.finally(() => {\n    css.remove(); // Write\n  });\n  return new Promise(resolve => {\n    transition.ready.then(() => {\n      const generatedViewAnimations = getViewAnimations();\n      const animations = [];\n      /**\n       * Create animations for each of our explicitly-defined subjects.\n       */\n      targets.forEach((definition, target) => {\n        // TODO: If target is not \"root\", resolve elements\n        // and iterate over each\n        for (const key of definitionNames) {\n          if (!definition[key]) continue;\n          const {\n            keyframes,\n            options\n          } = definition[key];\n          for (let [valueName, valueKeyframes] of Object.entries(keyframes)) {\n            if (!valueKeyframes) continue;\n            const valueOptions = {\n              ...getValueTransition(defaultOptions, valueName),\n              ...getValueTransition(options, valueName)\n            };\n            const type = chooseLayerType(key);\n            /**\n             * If this is an opacity animation, and keyframes are not an array,\n             * we need to convert them into an array and set an initial value.\n             */\n            if (valueName === \"opacity\" && !Array.isArray(valueKeyframes)) {\n              const initialValue = type === \"new\" ? 0 : 1;\n              valueKeyframes = [initialValue, valueKeyframes];\n            }\n            /**\n             * Resolve stagger function if provided.\n             */\n            if (typeof valueOptions.delay === \"function\") {\n              valueOptions.delay = valueOptions.delay(0, 1);\n            }\n            valueOptions.duration && (valueOptions.duration = motionUtils.secondsToMilliseconds(valueOptions.duration));\n            valueOptions.delay && (valueOptions.delay = motionUtils.secondsToMilliseconds(valueOptions.delay));\n            const animation = new NativeAnimation({\n              element: document.documentElement,\n              name: valueName,\n              pseudoElement: `::view-transition-${type}(${target})`,\n              keyframes: valueKeyframes,\n              transition: valueOptions\n            });\n            animations.push(animation);\n          }\n        }\n      });\n      /**\n       * Handle browser generated animations\n       */\n      for (const animation of generatedViewAnimations) {\n        if (animation.playState === \"finished\") continue;\n        const {\n          effect\n        } = animation;\n        if (!effect || !(effect instanceof KeyframeEffect)) continue;\n        const {\n          pseudoElement\n        } = effect;\n        if (!pseudoElement) continue;\n        const name = getLayerName(pseudoElement);\n        if (!name) continue;\n        const targetDefinition = targets.get(name.layer);\n        if (!targetDefinition) {\n          /**\n           * If transition name is group then update the timing of the animation\n           * whereas if it's old or new then we could possibly replace it using\n           * the above method.\n           */\n          const transitionName = name.type === \"group\" ? \"layout\" : \"\";\n          let animationTransition = {\n            ...getValueTransition(defaultOptions, transitionName)\n          };\n          animationTransition.duration && (animationTransition.duration = motionUtils.secondsToMilliseconds(animationTransition.duration));\n          animationTransition = applyGeneratorOptions(animationTransition);\n          const easing = mapEasingToNativeEasing(animationTransition.ease, animationTransition.duration);\n          effect.updateTiming({\n            delay: motionUtils.secondsToMilliseconds(animationTransition.delay ?? 0),\n            duration: animationTransition.duration,\n            easing\n          });\n          animations.push(new NativeAnimation({\n            animation\n          }));\n        } else if (hasOpacity(targetDefinition, \"enter\") && hasOpacity(targetDefinition, \"exit\") && effect.getKeyframes().some(keyframe => keyframe.mixBlendMode)) {\n          animations.push(new NativeAnimation({\n            animation\n          }));\n        } else {\n          animation.cancel();\n        }\n      }\n      resolve(new GroupAnimation(animations));\n    });\n  });\n}\nfunction hasOpacity(target, key) {\n  return target?.[key]?.keyframes.opacity;\n}\nlet builders = [];\nlet current = null;\nfunction next() {\n  current = null;\n  const [nextBuilder] = builders;\n  if (nextBuilder) start(nextBuilder);\n}\nfunction start(builder) {\n  motionUtils.removeItem(builders, builder);\n  current = builder;\n  startViewAnimation(builder).then(animation => {\n    builder.notifyReady(animation);\n    animation.finished.finally(next);\n  });\n}\nfunction processQueue() {\n  /**\n   * Iterate backwards over the builders array. We can ignore the\n   * \"wait\" animations. If we have an interrupting animation in the\n   * queue then we need to batch all preceeding animations into it.\n   * Currently this only batches the update functions but will also\n   * need to batch the targets.\n   */\n  for (let i = builders.length - 1; i >= 0; i--) {\n    const builder = builders[i];\n    const {\n      interrupt\n    } = builder.options;\n    if (interrupt === \"immediate\") {\n      const batchedUpdates = builders.slice(0, i + 1).map(b => b.update);\n      const remaining = builders.slice(i + 1);\n      builder.update = () => {\n        batchedUpdates.forEach(update => update());\n      };\n      // Put the current builder at the front, followed by any \"wait\" builders\n      builders = [builder, ...remaining];\n      break;\n    }\n  }\n  if (!current || builders[0]?.options.interrupt === \"immediate\") {\n    next();\n  }\n}\nfunction addToQueue(builder) {\n  builders.push(builder);\n  microtask.render(processQueue);\n}\nclass ViewTransitionBuilder {\n  constructor(update, options = {}) {\n    this.currentTarget = \"root\";\n    this.targets = new Map();\n    this.notifyReady = motionUtils.noop;\n    this.readyPromise = new Promise(resolve => {\n      this.notifyReady = resolve;\n    });\n    this.update = update;\n    this.options = {\n      interrupt: \"wait\",\n      ...options\n    };\n    addToQueue(this);\n  }\n  get(selector) {\n    this.currentTarget = selector;\n    return this;\n  }\n  layout(keyframes, options) {\n    this.updateTarget(\"layout\", keyframes, options);\n    return this;\n  }\n  new(keyframes, options) {\n    this.updateTarget(\"new\", keyframes, options);\n    return this;\n  }\n  old(keyframes, options) {\n    this.updateTarget(\"old\", keyframes, options);\n    return this;\n  }\n  enter(keyframes, options) {\n    this.updateTarget(\"enter\", keyframes, options);\n    return this;\n  }\n  exit(keyframes, options) {\n    this.updateTarget(\"exit\", keyframes, options);\n    return this;\n  }\n  crossfade(options) {\n    this.updateTarget(\"enter\", {\n      opacity: 1\n    }, options);\n    this.updateTarget(\"exit\", {\n      opacity: 0\n    }, options);\n    return this;\n  }\n  updateTarget(target, keyframes, options = {}) {\n    const {\n      currentTarget,\n      targets\n    } = this;\n    if (!targets.has(currentTarget)) {\n      targets.set(currentTarget, {});\n    }\n    const targetData = targets.get(currentTarget);\n    targetData[target] = {\n      keyframes,\n      options\n    };\n  }\n  then(resolve, reject) {\n    return this.readyPromise.then(resolve, reject);\n  }\n}\nfunction animateView(update, defaultOptions = {}) {\n  return new ViewTransitionBuilder(update, defaultOptions);\n}\n\n/**\n * @deprecated\n *\n * Import as `frame` instead.\n */\nconst sync = frame;\n/**\n * @deprecated\n *\n * Use cancelFrame(callback) instead.\n */\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = process => cancelFrame(process);\n  return acc;\n}, {});\nexports.GroupAnimation = GroupAnimation;\nexports.GroupAnimationWithThen = GroupAnimationWithThen;\nexports.MotionValue = MotionValue;\nexports.NativeAnimation = NativeAnimation;\nexports.ViewTransitionBuilder = ViewTransitionBuilder;\nexports.activeAnimations = activeAnimations;\nexports.animateView = animateView;\nexports.attachTimeline = attachTimeline;\nexports.calcGeneratorDuration = calcGeneratorDuration;\nexports.cancelFrame = cancelFrame;\nexports.cancelMicrotask = cancelMicrotask;\nexports.cancelSync = cancelSync;\nexports.collectMotionValues = collectMotionValues;\nexports.createGeneratorEasing = createGeneratorEasing;\nexports.createRenderBatcher = createRenderBatcher;\nexports.cubicBezierAsString = cubicBezierAsString;\nexports.frame = frame;\nexports.frameData = frameData;\nexports.frameSteps = frameSteps;\nexports.generateLinearEasing = generateLinearEasing;\nexports.getValueTransition = getValueTransition;\nexports.hover = hover;\nexports.isBezierDefinition = isBezierDefinition;\nexports.isDragActive = isDragActive;\nexports.isDragging = isDragging;\nexports.isGenerator = isGenerator;\nexports.isNodeOrChild = isNodeOrChild;\nexports.isPrimaryPointer = isPrimaryPointer;\nexports.isWaapiSupportedEasing = isWaapiSupportedEasing;\nexports.mapEasingToNativeEasing = mapEasingToNativeEasing;\nexports.maxGeneratorDuration = maxGeneratorDuration;\nexports.microtask = microtask;\nexports.motionValue = motionValue;\nexports.press = press;\nexports.recordStats = recordStats;\nexports.resolveElements = resolveElements;\nexports.setDragLock = setDragLock;\nexports.startWaapiAnimation = startWaapiAnimation;\nexports.statsBuffer = statsBuffer;\nexports.supportedWaapiEasing = supportedWaapiEasing;\nexports.supportsFlags = supportsFlags;\nexports.supportsLinearEasing = supportsLinearEasing;\nexports.supportsScrollTimeline = supportsScrollTimeline;\nexports.sync = sync;\nexports.time = time;","map":null,"metadata":{},"sourceType":"script"}